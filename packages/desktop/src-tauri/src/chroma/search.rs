//! Agentic Search
//!
//! Multi-step iterative search across Chroma collections.
//! Plan → Execute → Evaluate → Iterate → Synthesize

use std::collections::HashSet;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use thiserror::Error;
use tracing::{info, warn, debug};

use super::client::{ChromaClient, ChromaError, get_client};
use super::collections::*;

#[derive(Error, Debug)]
pub enum SearchError {
    #[error("Chroma error: {0}")]
    Chroma(#[from] ChromaError),
    #[error("No results found")]
    NoResults,
    #[error("Search not initialized")]
    NotInitialized,
}

impl Serialize for SearchError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(&self.to_string())
    }
}

/// A single search result from any collection
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct SearchHit {
    pub id: String,
    pub collection: String,
    pub document: String,
    pub metadata: Value,
    pub distance: f32,
    pub relevance: f32,
}

/// Combined search results across collections
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct SearchResults {
    pub hits: Vec<SearchHit>,
    pub collections_searched: Vec<String>,
    pub total_results: usize,
}

/// Search a single collection using embeddings generated by Chroma
async fn search_collection(
    client: &ChromaClient,
    collection_name: &str,
    query_texts: Vec<String>,
    n_results: u32,
    where_filter: Option<Value>,
) -> Result<Vec<SearchHit>, ChromaError> {
    // Get collection (read-only — don't create on search path)
    let collection = client.get_collection(collection_name).await?;

    // Check if collection has any records
    let count = client.count(&collection.id).await?;
    if count == 0 {
        return Ok(Vec::new());
    }

    let result = client.query(
        &collection.id,
        None, // no raw embeddings — let Chroma embed query_texts
        Some(query_texts),
        n_results,
        where_filter,
        None,
        Some(vec!["documents".to_string(), "metadatas".to_string(), "distances".to_string()]),
    ).await?;

    // Flatten the nested result structure
    let mut hits = Vec::new();

    for (query_idx, ids) in result.ids.iter().enumerate() {
        for (result_idx, id) in ids.iter().enumerate() {
            let document = result.documents.as_ref()
                .and_then(|d| d.get(query_idx))
                .and_then(|d| d.get(result_idx))
                .and_then(|d| d.clone())
                .unwrap_or_default();

            let metadata = result.metadatas.as_ref()
                .and_then(|m| m.get(query_idx))
                .and_then(|m| m.get(result_idx))
                .and_then(|m| m.clone())
                .unwrap_or(Value::Null);

            let distance = result.distances.as_ref()
                .and_then(|d| d.get(query_idx))
                .and_then(|d| d.get(result_idx))
                .copied()
                .unwrap_or(f32::MAX);

            // Convert distance to relevance (lower distance = higher relevance)
            // Chroma uses L2 distance by default; convert to 0-1 similarity
            let relevance = 1.0 / (1.0 + distance);

            hits.push(SearchHit {
                id: id.clone(),
                collection: collection_name.to_string(),
                document,
                metadata,
                distance,
                relevance,
            });
        }
    }

    Ok(hits)
}

/// Search across all Dialectic collections (concurrent)
pub async fn search_all(
    query: &str,
    n_results: u32,
    session_filter_value: Option<Value>,
    collections: Option<Vec<String>>,
) -> Result<SearchResults, SearchError> {
    let client = get_client();

    let truncated_query: String = query.chars().take(100).collect();
    let target_collections = collections.unwrap_or_else(|| {
        vec![
            COLLECTION_DOCUMENTS.to_string(),
            COLLECTION_OBSIDIAN.to_string(),
            COLLECTION_MEMORY_SEMANTIC.to_string(),
            COLLECTION_MEMORY_PROCEDURAL.to_string(),
            COLLECTION_MEMORY_EPISODIC.to_string(),
        ]
    });

    let collection_names: Vec<&str> = target_collections.iter().map(|s| s.as_str()).collect();
    info!(query = %truncated_query, n_results = n_results, collections = ?collection_names, "Cross-collection search");

    // Launch all collection searches concurrently
    let futures: Vec<_> = target_collections.iter().map(|collection_name| {
        let client = client.clone();
        let query = query.to_string();
        let filter = if collection_name == COLLECTION_DOCUMENTS {
            session_filter_value.clone()
        } else {
            None
        };
        let name = collection_name.clone();
        async move {
            let result = search_collection(
                &client,
                &name,
                vec![query],
                n_results,
                filter,
            ).await;
            (name, result)
        }
    }).collect();

    let results = futures::future::join_all(futures).await;

    let mut all_hits = Vec::new();
    let mut searched = Vec::new();

    for (name, result) in results {
        match result {
            Ok(hits) => {
                all_hits.extend(hits);
                searched.push(name);
            }
            Err(e) => {
                warn!(collection = %name, error = %e, "Search failed for collection");
            }
        }
    }

    // Sort by relevance (highest first)
    all_hits.sort_by(|a, b| b.relevance.partial_cmp(&a.relevance).unwrap_or(std::cmp::Ordering::Equal));

    let total = all_hits.len();

    // Limit total results
    all_hits.truncate(n_results as usize);

    debug!(total_hits = total, returned = all_hits.len(), "Merged cross-collection results");

    Ok(SearchResults {
        hits: all_hits,
        collections_searched: searched,
        total_results: total,
    })
}

/// Search within a specific session's documents
pub async fn search_session_documents(
    session_id: &str,
    query: &str,
    n_results: u32,
) -> Result<Vec<SearchHit>, SearchError> {
    debug!(session_id = %session_id, query = %query, "Searching session documents");
    let client = get_client();
    let filter = session_filter(session_id);
    let hits = search_collection(
        &client,
        COLLECTION_DOCUMENTS,
        vec![query.to_string()],
        n_results,
        Some(filter),
    ).await?;
    Ok(hits)
}

/// Search a specific document within a session
pub async fn search_document(
    session_id: &str,
    doc_id: &str,
    query: &str,
    n_results: u32,
) -> Result<Vec<SearchHit>, SearchError> {
    debug!(session_id = %session_id, doc_id = %doc_id, "Searching within document");
    let client = get_client();
    let filter = document_filter(session_id, doc_id);
    let hits = search_collection(
        &client,
        COLLECTION_DOCUMENTS,
        vec![query.to_string()],
        n_results,
        Some(filter),
    ).await?;
    Ok(hits)
}

/// A hit from cross-session related search
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct RelatedSessionHit {
    pub session_id: String,
    pub snippet: String,
    pub collection: String,
    pub relevance: f32,
}

/// Results from searching for related sessions
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct RelatedSessionResults {
    pub hits: Vec<RelatedSessionHit>,
    pub query_used: String,
}

/// Search for sessions related to a given title + summary.
/// Queries memory collections and documents, deduplicates by session_id,
/// and excludes the current session.
pub async fn search_related_sessions(
    title: &str,
    summary: Option<&str>,
    exclude_session_id: &str,
    n_results: u32,
) -> Result<RelatedSessionResults, SearchError> {
    // Build query from title + summary, capped to avoid oversized embedding requests
    let query: String = match summary {
        Some(s) if !s.is_empty() => format!("{} {}", title, s),
        _ => title.to_string(),
    }.chars().take(500).collect();

    debug!(query = %query, exclude = %exclude_session_id, "Searching related sessions");

    // Search memory collections (no session filter) + documents collection
    let memory_collections = vec![
        COLLECTION_MEMORY_SEMANTIC.to_string(),
        COLLECTION_MEMORY_PROCEDURAL.to_string(),
        COLLECTION_MEMORY_EPISODIC.to_string(),
    ];

    let memory_results = search_all(&query, n_results, None, Some(memory_collections)).await;
    let doc_results = search_all(&query, n_results, None, Some(vec![COLLECTION_DOCUMENTS.to_string()])).await;

    let mut seen_sessions = HashSet::new();
    seen_sessions.insert(exclude_session_id.to_string());
    let mut hits = Vec::new();

    // Process memory results
    if let Ok(memory) = memory_results {
        for hit in memory.hits {
            let sid = hit.metadata.get("session_id")
                .and_then(|v| v.as_str())
                .unwrap_or("")
                .to_string();
            if !sid.is_empty() && seen_sessions.insert(sid.clone()) {
                let snippet: String = hit.document.chars().take(120).collect();
                hits.push(RelatedSessionHit {
                    session_id: sid,
                    snippet,
                    collection: hit.collection,
                    relevance: hit.relevance,
                });
            }
        }
    }

    // Process document results
    if let Ok(docs) = doc_results {
        for hit in docs.hits {
            let sid = hit.metadata.get("session_id")
                .and_then(|v| v.as_str())
                .unwrap_or("")
                .to_string();
            if !sid.is_empty() && seen_sessions.insert(sid.clone()) {
                let snippet: String = hit.document.chars().take(120).collect();
                hits.push(RelatedSessionHit {
                    session_id: sid,
                    snippet,
                    collection: hit.collection,
                    relevance: hit.relevance,
                });
            }
        }
    }

    // Sort by relevance descending and truncate
    hits.sort_by(|a, b| b.relevance.partial_cmp(&a.relevance).unwrap_or(std::cmp::Ordering::Equal));
    hits.truncate(n_results as usize);

    info!(hits = hits.len(), query_len = query.len(), "Related session search complete");

    Ok(RelatedSessionResults {
        hits,
        query_used: query,
    })
}

// ============ TAURI COMMANDS ============

#[tauri::command]
pub async fn chroma_search_related_sessions(
    title: String,
    summary: Option<String>,
    exclude_session_id: String,
    n_results: u32,
) -> Result<RelatedSessionResults, SearchError> {
    crate::session::validate_session_id(&exclude_session_id)
        .map_err(|_| SearchError::Chroma(ChromaError::InvalidInput("Invalid session ID".to_string())))?;
    search_related_sessions(&title, summary.as_deref(), &exclude_session_id, n_results).await
}

#[tauri::command]
pub async fn chroma_search_all(
    query: String,
    n_results: u32,
    session_id: Option<String>,
    collections: Option<Vec<String>>,
) -> Result<SearchResults, SearchError> {
    let filter = if let Some(ref sid) = session_id {
        crate::session::validate_session_id(sid)
            .map_err(|_| SearchError::Chroma(ChromaError::InvalidInput("Invalid session ID".to_string())))?;
        Some(session_filter(sid))
    } else {
        None
    };
    search_all(&query, n_results, filter, collections).await
}

#[tauri::command]
pub async fn chroma_search_session(
    session_id: String,
    query: String,
    n_results: u32,
) -> Result<Vec<SearchHit>, SearchError> {
    crate::session::validate_session_id(&session_id)
        .map_err(|_| SearchError::Chroma(ChromaError::InvalidInput("Invalid session ID".to_string())))?;
    search_session_documents(&session_id, &query, n_results).await
}

#[tauri::command]
pub async fn chroma_search_document(
    session_id: String,
    doc_id: String,
    query: String,
    n_results: u32,
) -> Result<Vec<SearchHit>, SearchError> {
    crate::session::validate_session_id(&session_id)
        .map_err(|_| SearchError::Chroma(ChromaError::InvalidInput("Invalid session ID".to_string())))?;
    search_document(&session_id, &doc_id, &query, n_results).await
}
